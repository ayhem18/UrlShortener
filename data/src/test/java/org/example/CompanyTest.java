/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import org.assertj.core.api.Assertions;
import org.common.Subscription;
import org.common.SubscriptionManager;
import org.data.entities.Company;
import org.junit.jupiter.api.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.utils.CustomGenerator;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;


class CompanyTest {
    private final PasswordEncoder encoder = new BCryptPasswordEncoder();
    private final CustomGenerator gen = new CustomGenerator();

    private final ObjectMapper om = new ObjectMapper();

    private Map<String, String> getTokens() {
        return Map.of("owner", "owner_token1",
                "admin", "admin_token1",
                "registereduser", "ru_token1");
    }

    private Company getCompany() {
        return new Company("aaa", "www.youtube.com",
                SubscriptionManager.getSubscription("TIER_1"),
                getTokens(), this.encoder, this.gen);
    }

    @Test
    void testFirstJsonSerialization() throws JsonProcessingException, NoSuchFieldException, IllegalAccessException {
        List<String> initialFieldsSerialization = List.of("id",
                "siteId",
                "site",
                "roleTokens",
                "roleTokensHashed",
                "subscription");

        // the first time serializing a Company object must contain the following fields:
        // 1. id, siteId, site, roleTokens, roleTokensHashed, subscription
        Company com = getCompany();

        // before serializing the object; make sure none of the fields are Null
        for (Field f : com.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            assertNotNull(f.get(com));
        }

        // serialization
        String comJson = this.om.writeValueAsString(com);

        // after serializing the object; make sure none of the fields are Null
        for (Field f : com.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            assertNotNull(f.get(com));
        }

        // make sure the field used to condition the serialization is updated correctly
        // Otherwise, the serialization subsequently wouldn't work as intended
        Field f = Company.class.getDeclaredField("serializeSensitiveCount");
        f.setAccessible(true);
        assertEquals(4, (int) f.get(com));


        Object doc = Configuration.defaultConfiguration().jsonProvider().parse(comJson);
        Set<String> keys = JsonPath.read(doc, "keys()");
        Assertions.assertThat(keys).hasSameElementsAs(initialFieldsSerialization);

    }


    @Test
    void testJsonSerialization() throws JsonProcessingException, NoSuchFieldException, IllegalAccessException {
        List<String> serializationFields2 = List.of("site", "subscription");

        Company com = getCompany();

        // first serialization: increase the "serializeSensitiveCount" field to "4"
        this.om.writeValueAsString(com);
        Field f = Company.class.getDeclaredField("serializeSensitiveCount");
        f.setAccessible(true);
        // make sure the field used to condition the serialization is updated correctly
        // Otherwise, the serialization wouldn't work
        assertEquals(4, (int) f.get(com));


        // due to the conditional serialization, any subsequent serialization
        // should return only "site" and "subscription" as keys
        // the "serializeSensitiveCount" field should not  be modified

        String comJson;
        Object doc;
        for (int i = 0; i < 100; i++) {
            comJson = this.om.writeValueAsString(com);
            assertEquals(4, (int) f.get(com));

            doc = Configuration.defaultConfiguration().jsonProvider().parse(comJson);
            Set<String> keys = JsonPath.read(doc, "keys()");
            Assertions.assertThat(keys).hasSameElementsAs(serializationFields2);
        }

    }


    @Test
    void testSetTokens() {
        Company com = getCompany();
        // let's see how the setTokens function works
        Map<String, String> tokens = getTokens();

        Map<String, String> hashedTokens = com.getTokens();

        for (Map.Entry<String, String> entry : hashedTokens.entrySet()) {
            String key = entry.getKey();
            assertTrue(this.encoder.matches(tokens.get(key), entry.getValue()));
        }

        Map<String, String> newTokens = Map.of("owner", "new_owner_t",
                "admin", "new_admin_t",
                "registereduser", "new_ru_t");

        com.setTokens(newTokens, this.encoder);

        hashedTokens = com.getTokens();

        for (Map.Entry<String, String> entry : hashedTokens.entrySet()) {
            String key = entry.getKey();
            assertTrue(this.encoder.matches(newTokens.get(key), entry.getValue()));
        }
    }
}
