/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import org.assertj.core.api.Assertions;
import org.common.Subscription;
import org.common.SubscriptionManager;
import org.data.entities.Company;
import org.data.entities.CompanyWrapper;
import org.junit.jupiter.api.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.utils.CustomGenerator;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;


class CompanyTest {
    private final PasswordEncoder encoder = new BCryptPasswordEncoder();
    private final CustomGenerator gen = new CustomGenerator();

    private final ObjectMapper om = new ObjectMapper();

    private Map<String, String> getTokens() {
        return Map.of("owner", "owner_token1",
                "admin", "admin_token1",
                "registereduser", "ru_token1");
    }

    private Map<String, String> getRandomTokens() {
        return Map.of("owner", this.gen.randomString(10),
                "admin", this.gen.randomString(6),
                "registereduser", this.gen.randomString(6)
        );
    }


    @Test
    void testWrapperInitialization() throws NoSuchFieldException, IllegalAccessException {

        for (int i = 0; i < 10; i++) {
            String id = this.gen.randomString(6);
            String site = "www." + this.gen.randomAlphaString(7) + ".com";
            Subscription sub = SubscriptionManager.getSubscription("TIER_1");

            String siteId = this.gen.generateId(i);

            Map<String, String> tokens = getRandomTokens();
            CompanyWrapper w = new CompanyWrapper(id, site, sub, tokens, encoder, gen, i);

            // access the 'company' field via reflection
            Field fc = CompanyWrapper.class.getDeclaredField("company");
            fc.setAccessible(true);
            Company c = (Company) fc.get(w);


            Field f;

            f = Company.class.getDeclaredField("subscription");
            f.setAccessible(true);
            // make sure the get method and the value align with the input
            assertEquals(sub, f.get(c));
            assertEquals(sub, w.getSubscription());


            f = Company.class.getDeclaredField("site");
            f.setAccessible(true);
            // make sure the get method and the value align with the input
            assertEquals(site, f.get(c));
            assertEquals(site, w.getSite());


            f = Company.class.getDeclaredField("siteHash");
            f.setAccessible(true);
            // make sure the get method and the value align with the input
            assertEquals(siteId, f.get(c));
            assertEquals(siteId, w.getSiteId());

            f = Company.class.getDeclaredField("roleTokens");
            f.setAccessible(true);
            // make sure the get method and the value align with the input
            assertEquals(tokens, f.get(c));

            // make sure the hashing is done correctly
            f = Company.class.getDeclaredField("roleTokensHashed");
            f.setAccessible(true);
            Map<String, String> hTokens = (Map<String, String>) f.get(c);
            for (Map.Entry<String, String> entry: hTokens.entrySet()) {
                assertTrue(this.encoder.matches(tokens.get(entry.getKey()), entry.getValue()));
            }
        }
    }


    @Test
    void testFirstJsonSerialization() throws JsonProcessingException, NoSuchFieldException, IllegalAccessException {
        List<String> initialFieldsSerialization = List.of("id",
                "siteHash",
                "site",
                "roleTokens",
                "roleTokensHashed",
                "subscription");

        // the first time serializing a Company object must contain the following fields:
        // 1. id, siteId, site, roleTokens, roleTokensHashed, subscription

        String id = "aaa";
        String site = "www." + this.gen.randomAlphaString(7) + ".com";
        Subscription sub = SubscriptionManager.getSubscription("TIER_1");

        Map<String, String> tokens = getRandomTokens();
        CompanyWrapper w = new CompanyWrapper(id, site, sub, tokens, encoder, gen, 0);


        Field fc = CompanyWrapper.class.getDeclaredField("company");
        fc.setAccessible(true);
        Company com = (Company) fc.get(w);

        // before serializing the object; make sure none of the fields are Null
        for (Field f : com.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            assertNotNull(f.get(com));
        }

        // serialization
        String comJson = w.serialize(this.om);

        com = (Company) fc.get(w);

        // after serializing the object; make sure none of the fields are Null
        for (Field f : com.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            assertNotNull(f.get(com));
        }

        // make sure the field used to condition the serialization is updated correctly
        // Otherwise, the serialization subsequently wouldn't work as intended
        Field f = Company.class.getDeclaredField("serializeSensitiveCount");
        f.setAccessible(true);
        assertEquals(4, (int) f.get(com));

        Object doc = Configuration.defaultConfiguration().jsonProvider().parse(comJson);
        Set<String> keys = JsonPath.read(doc, "keys()");
        Assertions.assertThat(keys).hasSameElementsAs(initialFieldsSerialization);

    }

    @Test
    void testJsonSerialization() throws JsonProcessingException, NoSuchFieldException, IllegalAccessException {
        List<String> serializationFields2 = List.of("site", "subscription");

        String id = "aaa";
        String site = "www." + this.gen.randomAlphaString(7) + ".com";
        Subscription sub = SubscriptionManager.getSubscription("TIER_1");

        Map<String, String> tokens = getRandomTokens();
        CompanyWrapper w = new CompanyWrapper(id, site, sub, tokens, encoder, gen, 0);


        Field fc = CompanyWrapper.class.getDeclaredField("company");
        fc.setAccessible(true);


        // first serialization: increase the "serializeSensitiveCount" field to "4"
        w.serialize(this.om);
        Company com = (Company) fc.get(w);

        Field f = Company.class.getDeclaredField("serializeSensitiveCount");
        f.setAccessible(true);
        // make sure the field used to condition the serialization is updated correctly
        // Otherwise, the serialization wouldn't work
        assertEquals(4, (int) f.get(com));


        // due to the conditional serialization, any subsequent serialization
        // should return only "site" and "subscription" as keys
        // the "serializeSensitiveCount" field should not  be modified

        String comJson;
        Object doc;
        for (int i = 0; i < 100; i++) {
            comJson = w.serialize(this.om);
            com = (Company) fc.get(w);
            assertEquals(4, (int) f.get(com));

            doc = Configuration.defaultConfiguration().jsonProvider().parse(comJson);
            Set<String> keys = JsonPath.read(doc, "keys()");
            Assertions.assertThat(keys).hasSameElementsAs(serializationFields2);
        }

    }

    @Test
    void testSetTokens() throws NoSuchFieldException, IllegalAccessException {

        List<String> serializationFields2 = List.of("site", "subscription");

        String id = "aaa";
        String site = "www." + this.gen.randomAlphaString(7) + ".com";
        Subscription sub = SubscriptionManager.getSubscription("TIER_1");

        Map<String, String> tokens = getRandomTokens();
        CompanyWrapper w = new CompanyWrapper(id, site, sub, tokens, encoder, gen, 0);

        Field fc = CompanyWrapper.class.getDeclaredField("company");
        fc.setAccessible(true);

        Company com = (Company) fc.get(w);

        Map<String, String> hashedTokens = w.getTokens();

        for (Map.Entry<String, String> entry : hashedTokens.entrySet()) {
            String key = entry.getKey();
            assertTrue(this.encoder.matches(tokens.get(key), entry.getValue()));
        }

        Map<String, String> newTokens = Map.of("owner", "new_owner_t",
                "admin", "new_admin_t",
                "registereduser", "new_ru_t");

        w.setRoleTokens(newTokens, this.encoder);

        hashedTokens = w.getTokens();

        for (Map.Entry<String, String> entry : hashedTokens.entrySet()) {
            String key = entry.getKey();
            assertTrue(this.encoder.matches(newTokens.get(key), entry.getValue()));
        }
    }
}
