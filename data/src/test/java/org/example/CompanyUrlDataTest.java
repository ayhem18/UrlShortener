/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.assertj.core.api.Assertions;
import org.common.Subscription;
import org.common.SubscriptionManager;
import org.data.entities.Company;
import org.data.entities.CompanyUrlData;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.utils.CustomGenerator;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

@Disabled
class CompanyUrlDataTest {
    private final PasswordEncoder encoder = new BCryptPasswordEncoder();
    private final CustomGenerator gen = new CustomGenerator();

    private final ObjectMapper om = new ObjectMapper();

    private Map<String, String> getTokens() {
        return Map.of("owner", "owner_token1",
                "admin", "admin_token1",
                "registereduser", "ru_token1");
    }

//    private Company getCompany() {
//        Subscription sub = SubscriptionManager.getSubscription("TIER_1");
//
//        return new Company("aaa", "www.youtube.com", sub, getTokens(), this.encoder, this.gen);
//    }
//
//
//    @Test
//    @Disabled
//    void testAccessNoExistingLevel() {
//        Company com = getCompany();
//        CompanyUrlData data = new CompanyUrlData(com, "aaa");
//
//        for (UrlEntity e : UrlEntity.values()) {
//            for (int i = 2; i <= 10; i++) {
//                int finalI = i;
//                assertThrows(IllegalArgumentException.class, () -> data.addValue(finalI, e, "some_string", this.gen));
//            }
//        }
//    }
//
//    @Test
//    void testAccessingLastLevel() {
//        Company com = getCompany();
//        CompanyUrlData data = new CompanyUrlData(com, "aaa");
//
//        for (int i = 1; i <= 10; i++) {
//            // this call should not raise an exception
//            int finalI = i;
//            assertDoesNotThrow(() -> data.getLevelTypeData(finalI, UrlEntity.LEVEL_NAME));
//
//            // make sure it is added to the list as well
//            HashMap<UrlEntity, HashMap<String, String>> levelData = data.getDataEncoded().get(i - 1);
//            // make sure the mappings for all url entities were added
//            Assertions.assertThat(levelData.keySet()).hasSameElementsAs(Arrays.asList(UrlEntity.values()));
//
//            // make sure each one of them is empty
//            for (Map.Entry<UrlEntity, HashMap<String, String>> entry : levelData.entrySet()) {
//                assertEquals(entry.getValue().size(), 0);
//            }
//        }
//    }
//
//    @Test
//    void testAddingRepeatedElements() {
//        Company com = getCompany();
//        CompanyUrlData data = new CompanyUrlData(com, "aaa");
//
//        List<String> level1String = List.of("s11", "s12", "s13");
////        List<String> level2String = List.of("s21", "s22", "s23");
////        List<String> level3String = List.of("s31", "s32", "s33");
//
//        List<Map<String, String>> levels1 = List.of(
//                Map.of("s11", "a"),
//                Map.of("s11", "a", "s12", "b"),
//                Map.of("s11", "a", "s12", "b", "s13", "c")
//        );
//
//        // add all levels empty
//        for (int i = 1; i <= 3; i++) {
//            data.getLevelTypeData(i, UrlEntity.LEVEL_NAME);
//        }
//
//        // add the first level
//        for (int stringIndex = 0; stringIndex < 3; stringIndex ++) {
//            // add it to the LEVEL name portion
//            data.addValue(1, UrlEntity.LEVEL_NAME, level1String.get(stringIndex), this.gen);
//            Map<String, String> levelNameLevel1 = data.getLevelTypeData(1, UrlEntity.LEVEL_NAME).getKey();
//            assertEquals(levelNameLevel1, levels1.get(stringIndex));
//
//            for (UrlEntity ue : UrlEntity.values()) {
//                if (ue == UrlEntity.LEVEL_NAME) {
//                    continue;
//                }
//                // make sure the hashmap for the other entities are empty
//                Map<String, String> otherUeLevels = data.getLevelTypeData(1, ue).getKey();
//                assertEquals(otherUeLevels.size(), 0);
//            }
//        }
//
//        // after filling level 1, LEVEL_NAME, adding any of the same values should not alter the map
//        for (int j = 0; j < 100; j++) {
//            int stringIndex = (new Random()).nextInt(0, 3);
//            data.addValue(1, UrlEntity.LEVEL_NAME, level1String.get(stringIndex), this.gen);
//            Map<String, String> levelNameLevel1 = data.getLevelTypeData(1, UrlEntity.LEVEL_NAME).getKey();
//            assertEquals(levelNameLevel1, levels1.get(2));
//        }
//
//        for (int level = 1; level < 3; level ++) {
//            Map<UrlEntity, HashMap<String, String>> levelData = data.getDataEncoded().get(level);
//            for (UrlEntity ue : UrlEntity.values()) {
//                assertEquals(levelData.get(ue).size(), 0);
//            }
//        }
//    }
}
