/*
 * This source file was generated by the Gradle 'init' task
 */
package org.url;

import org.junit.jupiter.api.Test;
import org.utils.CustomGenerator;

import java.util.List;
import java.util.Map;
import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

class UrlUtilitiesTest {

    private final UrlEncoder decoder = new UrlEncoder(new CustomGenerator());
    

    @Test
    void testPathVariableDetection() {        
        // Test URLs with various segment patterns
        String alphabeticSegment = "users";         // Should be a level name
        String alphaWithUnderscores = "user_data";  // Should be a level name
        String alphaWithHyphens = "user-profile";   // Should be a level name
        
        // These should all be detected as path variables, not level names
        String numeric = "12345"; 
        String alphaNumeric = "user123";
        String withSpecialChars = "doc@version";
        
        // Create test URLs
        String url1 = "https://example.com/" + alphabeticSegment + "/" + numeric;
        String url2 = "https://example.com/" + alphaWithUnderscores + "/" + alphaNumeric;
        String url3 = "https://example.com/" + alphaWithHyphens + "/" + withSpecialChars;
        
        // Parse URLs
        List<UrlLevelEntity> result1 = decoder.breakdown(url1);
        List<UrlLevelEntity> result2 = decoder.breakdown(url2);
        List<UrlLevelEntity> result3 = decoder.breakdown(url3);
        
        // Verify level name detection
        assertEquals(alphabeticSegment, result1.get(2).levelName());
        assertEquals(alphaWithUnderscores, result2.get(2).levelName());
        assertEquals(alphaWithHyphens, result3.get(2).levelName());
        
        // Verify path variable detection
        assertEquals(numeric, result1.get(3).pathVariable());
        assertEquals(alphaNumeric, result2.get(3).pathVariable());
        assertEquals(withSpecialChars, result3.get(3).pathVariable());
    }


    @Test
    void testUrlDecoderOneLevel() {
        List<String> oneLevelUrls = List.of(
                "https://youtube.com",
                "https://www.github.edu",
                "http://another111site.eu",
                "http://well_yeye_here_we666.org",
                "https://facebook.com",
                "http://stackoverflow.com",
                "https://www.amazon.com",
                "http://microsoft.net",
                "https://apple.com",
                "http://www.intel.co",
                "https://nvidia.io",
                "http://ibm.org",
                "https://www.netflix.com",
                "http://twitter.com",
                "https://tesla123.com",
                "http://www.harvard.edu",
                "https://linux.org",
                "http://www.mit.edu",
                "https://dev2dev.io",
                "http://coding4fun.net",
                "https://www.py-data.org",
                "http://java-world.com",
                "https://cloud9.io",
                "http://www.tech-daily.info"
        );

        List<String> levelNames = List.of(
                "youtube.com",
                "www.github.edu",
                "another111site.eu",
                "well_yeye_here_we666.org",
                "facebook.com",
                "stackoverflow.com",
                "www.amazon.com",
                "microsoft.net",
                "apple.com",
                "www.intel.co",
                "nvidia.io",
                "ibm.org",
                "www.netflix.com",
                "twitter.com",
                "tesla123.com",
                "www.harvard.edu",
                "linux.org",
                "www.mit.edu",
                "dev2dev.io",
                "coding4fun.net",
                "www.py-data.org",
                "java-world.com",
                "cloud9.io",
                "www.tech-daily.info"
        );

        List<String> protocolNames = List.of(
                "https://", "https://", "http://", "http://",
                "https://", "http://", "https://", "http://",
                "https://", "http://", "https://", "http://",
                "https://", "http://", "https://", "http://",
                "https://", "http://", "https://", "http://",
                "https://", "http://", "https://", "http://"
        );

        // test the breakdown of the url
        for (int i = 0; i < oneLevelUrls.size(); i++) {
            String url = oneLevelUrls.get(i);
            String topLevel = levelNames.get(i);

            List<UrlLevelEntity> levels = decoder.breakdown(url);
            // make sure it is 2 levels: one for the protocol and one for the level     
            assertEquals(levels.size(), 2);
            
            // make sure the level is extracted correctly
            assertEquals(new UrlLevelEntity(protocolNames.get(i), null, null, null), levels.getFirst());
            assertEquals(new UrlLevelEntity(topLevel, null, null, null), levels.getLast());
        }
    }

    @Test
    void testLongUrls() {

        // fully manual tests

        String u1 = "https://github.com/ayhem18/Towards_Data_Science/blob/main/Programming_Tools/Databases/Practice/sqlpad";
        List<UrlLevelEntity> e1 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("github.com", null, null, null),
                new UrlLevelEntity(null, "ayhem18", null, null),
                new UrlLevelEntity("Towards_Data_Science", null , null, null),
                new UrlLevelEntity("blob", null, null, null),
                new UrlLevelEntity("main", null, null, null),
                new UrlLevelEntity("Programming_Tools", null, null, null),
                new UrlLevelEntity("Databases", null, null, null),
                new UrlLevelEntity("Practice", null, null, null),
                new UrlLevelEntity("sqlpad", null, null, null)
        );

        List<UrlLevelEntity> l1 = decoder.breakdown(u1);
        assertEquals(l1, e1);

        String u2 = "https://github.com/ayhem18?tab=overview&from=2025-01-01&to=2025-01-22";

        List<UrlLevelEntity> e2 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("github.com", null, null, null),
                new UrlLevelEntity(null, "ayhem18",
                        List.of("tab", "from", "to"),
                        List.of("overview", "2025-01-01", "2025-01-22")
                        )
        );

        List<UrlLevelEntity> l2 = decoder.breakdown(u2);
        assertEquals(l2, e2);
    }

    @Test
    void testExtendedUrlPatterns() {
        //tests generated by Cursor and verified by me ))

        // TEST CASE 1: URL with multiple path segments and query parameters
        String url1 = "https://www.amazon.com/dp/B07PXGQC1Q/ref=cm_sw_r_cp_api_glt_i_A1V2K8HE8RS8ZWP0DTY7?_encoding=UTF8&psc=1";
        List<UrlLevelEntity> expected1 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("www.amazon.com", null, null, null),
                new UrlLevelEntity("dp", null, null, null),
                new UrlLevelEntity(null, "B07PXGQC1Q", null, null),
                new UrlLevelEntity(null, "ref=cm_sw_r_cp_api_glt_i_A1V2K8HE8RS8ZWP0DTY7",
                        List.of("_encoding", "psc"), 
                        List.of("UTF8", "1"))
        );
        assertEquals(expected1, decoder.breakdown(url1));

        // TEST CASE 2: Academic URL with multiple segments
        String url2 = "https://dl.acm.org/doi/proceedings/10.1145/3442188";
        List<UrlLevelEntity> expected2 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("dl.acm.org", null, null, null),
                new UrlLevelEntity("doi", null, null, null),
                new UrlLevelEntity("proceedings", null, null, null),
                new UrlLevelEntity(null, "10.1145", null, null),
                new UrlLevelEntity(null, "3442188", null, null)
        );
        assertEquals(expected2, decoder.breakdown(url2));

        // TEST CASE 3: URL with multiple query parameters
        String url3 = "https://www.google.com/search?q=spring+boot&oq=spring+boot&aqs=chrome..69i57j0l7.3j0j7&sourceid=chrome&ie=UTF-8";
        List<UrlLevelEntity> expected3 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("www.google.com", null, null, null),
                new UrlLevelEntity("search", 
                        null,
                        List.of("q", "oq", "aqs", "sourceid", "ie"),
                        List.of("spring+boot", "spring+boot", "chrome..69i57j0l7.3j0j7", "chrome", "UTF-8"))
        );
        assertEquals(expected3, decoder.breakdown(url3));

        // TEST CASE 4: E-commerce URL with filters
        String url4 = "https://shop.example.com/category/electronics/smartphones?brand=apple&price=500-1000&sort=price-asc";
        List<UrlLevelEntity> expected4 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("shop.example.com", null, null, null),
                new UrlLevelEntity("category", null, null, null),
                new UrlLevelEntity("electronics", null, null, null),
                new UrlLevelEntity("smartphones", 
                        null,
                        List.of("brand", "price", "sort"),
                        List.of("apple", "500-1000", "price-asc"))
        );
        assertEquals(expected4, decoder.breakdown(url4));

        // TEST CASE 5: URL with fragment identifier
        String url5 = "https://developer.mozilla.org/en-US/docs/Web/API/URL_API?section=methods#constructor";
        List<UrlLevelEntity> expected5 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("developer.mozilla.org", null, null, null),
                new UrlLevelEntity("en-US",null , null, null),
                new UrlLevelEntity("docs", null, null, null),
                new UrlLevelEntity("Web", null, null, null),
                new UrlLevelEntity("API", null, null, null),
                new UrlLevelEntity("URL_API", 
                        null,
                        List.of("section"),
                        List.of("methods#constructor"))
        );
        assertEquals(expected5, decoder.breakdown(url5));
        
        // TEST CASE 6: Video streaming URL with timestamp
        String url6 = "https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=42s&ab_channel=RickAstley";
        List<UrlLevelEntity> expected6 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("www.youtube.com", null, null, null),
                new UrlLevelEntity("watch", 
                        null,
                        List.of("v", "t", "ab_channel"),
                        List.of("dQw4w9WgXcQ", "42s", "RickAstley"))
        );
        assertEquals(expected6, decoder.breakdown(url6));
        
        // TEST CASE 7: Social media profile URL
        String url7 = "https://twitter.com/elonmusk/status/1615488596264652800";
        List<UrlLevelEntity> expected7 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("twitter.com", null, null, null),
                new UrlLevelEntity("elonmusk", null, null, null),
                new UrlLevelEntity("status", null, null, null),
                new UrlLevelEntity(null, "1615488596264652800", null, null)
        );
        assertEquals(expected7, decoder.breakdown(url7));
        
        // TEST CASE 8: URL with IP address instead of domain
        String url8 = "http://192.168.1.1/admin/settings?section=network&debug=true";
        List<UrlLevelEntity> expected8 = List.of(
                new UrlLevelEntity("http://", null, null, null),
                new UrlLevelEntity("192.168.1.1", null, null, null),
                new UrlLevelEntity("admin", null, null, null),
                new UrlLevelEntity("settings", 
                        null,
                        List.of("section", "debug"),
                        List.of("network", "true"))
        );
        assertEquals(expected8, decoder.breakdown(url8));
        
        // TEST CASE 9: URL with subdomain and port number
        String url9 = "https://api.example.com:8443/v2/users/123456/profile";
        List<UrlLevelEntity> expected9 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("api.example.com:8443", null, null, null),
                new UrlLevelEntity(null, "v2", null, null),
                new UrlLevelEntity("users", null, null, null),
                new UrlLevelEntity(null, "123456", null, null),
                new UrlLevelEntity("profile", null, null, null)
        );
        assertEquals(expected9, decoder.breakdown(url9));
        
        // TEST CASE 10: URL with encoded characters
        String url10 = "https://example.com/search?q=space%20odyssey&year=1968";
        List<UrlLevelEntity> expected10 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("example.com", null, null, null),
                new UrlLevelEntity("search", 
                        null,
                        List.of("q", "year"),
                        List.of("space%20odyssey", "1968"))
        );
        assertEquals(expected10, decoder.breakdown(url10));
        
        // TEST CASE 11: Document URL with file extension
        String url11 = "https://docs.example.org/files/presentation.pdf";
        List<UrlLevelEntity> expected11 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("docs.example.org", null, null, null),
                new UrlLevelEntity("files", null, null, null),
                new UrlLevelEntity(null, "presentation.pdf", null, null)
        );
        assertEquals(expected11, decoder.breakdown(url11));
        
        // TEST CASE 12: Banking URL with secure parameters
        String url12 = "https://banking.example.com/account/transfers?from=1234567890&to=0987654321&amount=500.00&currency=USD";
        List<UrlLevelEntity> expected12 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("banking.example.com", null, null, null),
                new UrlLevelEntity("account", null, null, null),
                new UrlLevelEntity("transfers", 
                        null,
                        List.of("from", "to", "amount", "currency"),
                        List.of("1234567890", "0987654321", "500.00", "USD"))
        );
        assertEquals(expected12, decoder.breakdown(url12));
        
        // TEST CASE 13: Map URL with coordinates
        String url13 = "https://maps.example.com/view?lat=37.7749&lng=-122.4194&zoom=12&mode=satellite";
        List<UrlLevelEntity> expected13 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("maps.example.com", null, null, null),
                new UrlLevelEntity("view", 
                        null,
                        List.of("lat", "lng", "zoom", "mode"),
                        List.of("37.7749", "-122.4194", "12", "satellite"))
        );
        assertEquals(expected13, decoder.breakdown(url13));
        
        // TEST CASE 14: URL with multiple numeric path segments
        String url14 = "https://api.github.com/repos/octocat/Hello-World/issues/1347";
        List<UrlLevelEntity> expected14 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("api.github.com", null, null, null),
                new UrlLevelEntity("repos", null, null, null),
                new UrlLevelEntity("octocat", null, null, null),
                new UrlLevelEntity("Hello-World", null, null, null),
                new UrlLevelEntity("issues", null, null, null),
                new UrlLevelEntity(null, "1347", null, null)
        );
        assertEquals(expected14, decoder.breakdown(url14));
        
        // TEST CASE 15: News article URL with date structure
        String url15 = "https://news.example.com/2023/03/15/technology/ai-breakthrough-research.html";
        List<UrlLevelEntity> expected15 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("news.example.com", null, null, null),
                new UrlLevelEntity(null, "2023", null, null),
                new UrlLevelEntity(null, "03", null, null),
                new UrlLevelEntity(null, "15", null, null),
                new UrlLevelEntity("technology", null, null, null),
                new UrlLevelEntity(null, "ai-breakthrough-research.html", null, null)
        );
        assertEquals(expected15, decoder.breakdown(url15));
        
        // TEST CASE 16: URL with JWT token in query parameter
        String url16 = "https://auth.example.com/validate?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U";
        List<UrlLevelEntity> expected16 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("auth.example.com", null, null, null),
                new UrlLevelEntity("validate", 
                        null,
                        List.of("token"),
                        List.of("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U"))
        );
        assertEquals(expected16, decoder.breakdown(url16));
        
        // TEST CASE 17: E-learning platform course URL
        String url17 = "https://learn.example.edu/course/CS101/module/3/lesson/4?completionStatus=inProgress";
        List<UrlLevelEntity> expected17 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("learn.example.edu", null, null, null),
                new UrlLevelEntity("course", null, null, null),
                new UrlLevelEntity(null, "CS101", null, null),
                new UrlLevelEntity("module", null, null, null),
                new UrlLevelEntity(null, "3", null, null),
                new UrlLevelEntity("lesson", null, null, null),
                new UrlLevelEntity(null, "4", 
                        List.of("completionStatus"),
                        List.of("inProgress"))
        );
        assertEquals(expected17, decoder.breakdown(url17));
        
        // TEST CASE 18: URL with path parameters and API version
        String url18 = "https://api.example.io/v3/products/electronics/categories/smartphones";
        List<UrlLevelEntity> expected18 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("api.example.io", null, null, null),
                new UrlLevelEntity(null, "v3", null, null),
                new UrlLevelEntity("products", null, null, null),
                new UrlLevelEntity("electronics", null, null, null),
                new UrlLevelEntity("categories", null, null, null),
                new UrlLevelEntity("smartphones", null, null, null)
        );
        assertEquals(expected18, decoder.breakdown(url18));
        
        // TEST CASE 19: Health tracking API URL with multiple parameters
        String url19 = "https://health-api.example.net/users/42/metrics?type=steps&from=2023-01-01&to=2023-01-31&aggregation=daily";
        List<UrlLevelEntity> expected19 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("health-api.example.net", null, null, null),
                new UrlLevelEntity("users", null, null, null),
                new UrlLevelEntity(null, "42", null, null),
                new UrlLevelEntity("metrics", 
                        null,
                        List.of("type", "from", "to", "aggregation"),
                        List.of("steps", "2023-01-01", "2023-01-31", "daily"))
        );
        assertEquals(expected19, decoder.breakdown(url19));
        
        // TEST CASE 20: URL with mixed path segments and complex query parameters
        String url20 = "https://analytics.example.com/dashboard/2023/Q1/performance?metrics=revenue,users,conversion&compare=2022-Q1&format=chart&theme=dark";
        List<UrlLevelEntity> expected20 = List.of(
                new UrlLevelEntity("https://", null, null, null),
                new UrlLevelEntity("analytics.example.com", null, null, null),
                new UrlLevelEntity("dashboard", null, null, null),
                new UrlLevelEntity(null, "2023", null, null),
                new UrlLevelEntity(null, "Q1", null, null),
                new UrlLevelEntity("performance", 
                        null,
                        List.of("metrics", "compare", "format", "theme"),
                        List.of("revenue,users,conversion", "2022-Q1", "chart", "dark"))
        );
        assertEquals(expected20, decoder.breakdown(url20));
    }

    @Test
    void testEncodeMinimumLengthRequirements() {
        CustomGenerator cs = new CustomGenerator();

        // Setup data structures to store encoding mappings
        List<Map<String, String>> encodedData = new ArrayList<>();
        List<Map<String, String>> decodedData = new ArrayList<>();
        
        // Characters that make a string a path variable instead of a level name (anything not alphabetic, _, or -)
        String pathVarChars = "0123456789!@#$%";
        
        // Test with different minimum length requirements
        for (int minVarLength = 8; minVarLength <= 12; minVarLength++) {
            for (int minParamLength = 5; minParamLength <= 9; minParamLength++) {
                // Reset data structures for each test configuration
                encodedData.clear();
                decodedData.clear();
                
                // Generate test domain hash
                String domainHash = "sh.rt";
                
                // Create short path variables (length < minVarLength)
                // Make sure they contain numbers or special chars to be recognized as path variables
                String shortPathVar1 = cs.randomAlphaString(minVarLength - 4) + cs.randomStringFromChars(3, pathVarChars);
                String shortPathVar2 = cs.randomAlphaString(minVarLength - 4) + cs.randomStringFromChars(3, pathVarChars);
                
                // Create short level names and parameter names (length < minParamLength)
                String shortLevelName = cs.randomAlphaString(minParamLength - 2);
                String shortParamName = cs.randomAlphaString(minParamLength - 1);
                String shortParamValue = cs.randomStringFromChars(3, pathVarChars) + cs.randomAlphaString(minVarLength - 4) ;
                
                // Create long segments (should be encoded)
                String longLevelName = cs.randomAlphaString(minParamLength + 5);
                // Ensure the path variable has non-alphabetic characters
                String longPathVar = cs.randomAlphaString(minVarLength + 2) + cs.randomStringFromChars(3, pathVarChars);
                String longParamName = cs.randomAlphaString(minParamLength + 3);
                String longParamValue = cs.randomAlphaString(minVarLength - 4) + cs.randomStringFromChars(6, pathVarChars);

                // Create test URLs with these segments
                String url1 = "https://example.com/" + shortLevelName + "/" + longPathVar;
                String url2 = "https://example.com/" + longLevelName + "/" + shortPathVar1;
                String url3 = "https://example.com/api/" + shortLevelName + "?" + shortParamName + "=" + shortParamValue;
                String url4 = "https://example.com/api/" + longLevelName + "?" + longParamName + "=" + longParamValue;
                String url5 = "https://example.com/" + shortLevelName + "/" + shortPathVar2 + "?" + longParamName + "=" + shortParamValue;
                
                // Test URL 1 - short level name with long path variable
                String encoded1 = decoder.encode(url1, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // URL 1 assertions
                assertTrue(encoded1.contains(shortLevelName), 
                    "Short level name (" + shortLevelName + ") should not be encoded with minParamLength=" + minParamLength);
                assertFalse(encoded1.contains(longPathVar), 
                    "Long path variable (" + longPathVar + ") should be encoded with minVarLength=" + minVarLength);
                
                // Test URL 2 - long level name with short path variable
                String encoded2 = decoder.encode(url2, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // URL 2 assertions
                assertFalse(encoded2.contains(longLevelName), 
                    "Long level name (" + longLevelName + ") should be encoded with minParamLength=" + minParamLength);
                assertTrue(encoded2.contains(shortPathVar1), 
                    "Short path variable (" + shortPathVar1 + ") should not be encoded with minVarLength=" + minVarLength);
                
                // Test URL 3 - short segments throughout
                String encoded3 = decoder.encode(url3, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // URL 3 assertions
                assertTrue(encoded3.contains(shortLevelName), 
                    "Short level name should not be encoded");
                assertTrue(encoded3.contains(shortParamName), 
                    "Short parameter name should not be encoded");
                assertTrue(encoded3.contains(shortParamValue), 
                    "Short parameter value should not be encoded");
                
                // Test URL 4 - long segments throughout
                String encoded4 = decoder.encode(url4, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // URL 4 assertions
                assertFalse(encoded4.contains(longLevelName), 
                    "Long level name should be encoded");
                assertFalse(encoded4.contains(longParamName), 
                    "Long parameter name should be encoded");
                assertFalse(encoded4.contains(longParamValue), 
                    "Long parameter value should be encoded");
                
                // Test URL 5 - mixed short and long segments
                String encoded5 = decoder.encode(url5, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // URL 5 assertions
                assertTrue(encoded5.contains(shortLevelName), 
                    "Short level name should not be encoded");
                assertTrue(encoded5.contains(shortPathVar2), 
                    "Short path variable should not be encoded");
                assertFalse(encoded5.contains(longParamName), 
                    "Long parameter name should be encoded");
                assertTrue(encoded5.contains(shortParamValue), 
                    "Short parameter value should not be encoded");
                
            }
        }
    }

    @Test
    void testEncodePersistenceAndReuse() {
        // Setup data structures to store encoding mappings
        List<Map<String, String>> encodedData = new ArrayList<>();
        List<Map<String, String>> decodedData = new ArrayList<>();
        String domainHash = "example.hash";
        int minVarLength = 8;
        int minParamLength = 6;
        
        // Create test URLs with common segments
        String commonLevelName = "profile";
        String commonPathVar = "123456789";
        String commonParamName = "filter";
        String commonParamValue = "active";
        
        String url1 = "https://example.com/" + commonLevelName + "/" + commonPathVar;
        String url2 = "https://example.com/users/" + commonPathVar + "/details";
        String url3 = "https://example.com/search?" + commonParamName + "=" + commonParamValue;
        String url4 = "https://example.com/" + commonLevelName + "?" + commonParamName + "=" + commonParamValue;
        
        // First encode all URLs
        String encoded1 = decoder.encode(url1, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        String encoded2 = decoder.encode(url2, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        String encoded3 = decoder.encode(url3, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        String encoded4 = decoder.encode(url4, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        
        // Extract encoded values from the mappings
        String encodedLevelName = null;
        String encodedPathVar = null;
        String encodedParamName = null;
        String encodedParamValue = null;
        
        for (Map<String, String> mappings : encodedData) {
            if (mappings.containsKey(commonLevelName)) {
                encodedLevelName = mappings.get(commonLevelName);
            }
            if (mappings.containsKey(commonPathVar)) {
                encodedPathVar = mappings.get(commonPathVar);
            }
            if (mappings.containsKey(commonParamName)) {
                encodedParamName = mappings.get(commonParamName);
            }
            if (mappings.containsKey(commonParamValue)) {
                encodedParamValue = mappings.get(commonParamValue);
            }
        }
        
        // Assert that encoded values are found in appropriate URL encodings
        assertNotNull(encodedLevelName, "Common level name should be encoded");
        assertNotNull(encodedPathVar, "Common path variable should be encoded");
        assertNotNull(encodedParamName, "Common parameter name should be encoded");
        assertNotNull(encodedParamValue, "Common parameter value should be encoded");
        
        assertTrue(encoded1.contains(encodedLevelName), "URL1 should contain encoded level name");
        assertTrue(encoded1.contains(encodedPathVar), "URL1 should contain encoded path variable");
        
        assertTrue(encoded2.contains(encodedPathVar), "URL2 should contain encoded path variable");
        
        assertTrue(encoded3.contains(encodedParamName), "URL3 should contain encoded parameter name");
        assertTrue(encoded3.contains(encodedParamValue), "URL3 should contain encoded parameter value");
        
        assertTrue(encoded4.contains(encodedLevelName), "URL4 should contain encoded level name");
        assertTrue(encoded4.contains(encodedParamName), "URL4 should contain encoded parameter name");
        assertTrue(encoded4.contains(encodedParamValue), "URL4 should contain encoded parameter value");
        
        // Now create new URLs with the same segments to verify reuse
        String newUrl1 = "https://example.com/articles/" + commonPathVar;
        String newUrl2 = "https://example.com/" + commonLevelName + "/settings";
        
        String newEncoded1 = decoder.encode(newUrl1, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        String newEncoded2 = decoder.encode(newUrl2, domainHash, encodedData, decodedData, minVarLength, minParamLength);
        
        // Verify encoded segments are reused
        assertTrue(newEncoded1.contains(encodedPathVar), 
            "New URL should reuse the same encoding for the common path variable");
        assertTrue(newEncoded2.contains(encodedLevelName), 
            "New URL should reuse the same encoding for the common level name");
    }

    @Test
    void testUrlEncodingWithStructuredSegments() {
        // Setup data structures to store encoding mappings
        List<Map<String, String>> encodedData = new ArrayList<>();
        List<Map<String, String>> decodedData = new ArrayList<>();
        String domainHash = "shortdomain.co";
        int minVarLength = 10;
        int minParamLength = 8;
        
        // For each level (0, 1, 2), create structured test segments
        String[][][] segments = new String[3][4][3]; // [level][type][index]
        
        // Types are: 0=pathVariable, 1=levelName, 2=paramName, 3=paramValue
        for (int level = 0; level < 3; level++) {
            for (int typeIndex = 0; typeIndex < 4; typeIndex++) {
                for (int itemIndex = 0; itemIndex < 3; itemIndex++) {
                    // Generate different patterns for each type
                    switch(typeIndex) {
                        case 0: // Path variables - add numbers to ensure they're detected as path variables
                            segments[level][typeIndex][itemIndex] = 
                                "level" + level + "_path_variable" + itemIndex + "_" + (level + 10 * itemIndex);
                            break;
                        case 1: // Level names - use only alphabetic characters and underscores
                            segments[level][typeIndex][itemIndex] = 
                                "level" + level + "_level_name" + itemIndex;
                            break;
                        case 2: // Parameter names
                            segments[level][typeIndex][itemIndex] = 
                                "level" + level + "_param_name" + itemIndex;
                            break;
                        case 3: // Parameter values
                            segments[level][typeIndex][itemIndex] = 
                                "level" + level + "_param_value" + itemIndex + "_" + (level + 10 * itemIndex);
                            break;
                    }
                }
            }
        }
        
        // Create a CustomGenerator instance for ID generation verification
        CustomGenerator cs = new CustomGenerator();
        
        // Test URLs with just domain + level name
        String protocol = "https://";
        
        // Test all level names from the first level (level 0)
        for (int i = 0; i < 3; i++) {
            // Get the level name for this iteration
            String levelName = segments[0][1][i]; // level 0, type 1 (level name), index i
            
            // Make sure the level name is long enough to be encoded
            if (levelName.length() >= minParamLength) {
                // Create URL with domain + level name
                String url = protocol + "example.com/" + levelName;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                String levelName_id = cs.generateId(i);


                // Verify the encoding follows expected pattern: protocol://domainHash/generatedId
                String expectedPattern = protocol + domainHash + "/" + levelName_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with generated ID");


                assertTrue(encodedData.getFirst().containsKey(levelName), "Encoded data should contain the generated ID");
                assertEquals(encodedData.getFirst().get(levelName), levelName_id, "Encoded data should contain the generated ID");
                assertTrue( decodedData.getFirst().containsKey(levelName_id), "Encoded data should contain the generated ID");
                assertEquals(decodedData.getFirst().get(levelName_id), levelName, "Encoded data should contain the generated ID");
            }
        }

        // After the level name test loop, add this code to test path variables
        // Test all path variables from the first level (level 0)
        for (int i = 0; i < 3; i++) {
            // Get the path variable for this iteration
            String pathVariable = segments[0][0][i]; // level 0, type 0 (path variable), index i
            
            // Make sure the path variable is long enough to be encoded
            if (pathVariable.length() >= minVarLength) {
                // Create URL with domain + path variable
                String url = protocol + "example.com/" + pathVariable;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // Path variables should get IDs starting after the level names (i + 3)
                String pathVar_id = cs.generateId(i + 3);
                
                // Verify the encoding follows expected pattern: protocol://domainHash/generatedId
                String expectedPattern = protocol + domainHash + "/" + pathVar_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with generated ID for path variable");
                
                // Verify the mappings were created correctly
                assertTrue(encodedData.getFirst().containsKey(pathVariable), 
                    "Encoded data should contain the generated ID for path variable");
                assertEquals(encodedData.getFirst().get(pathVariable), pathVar_id, 
                    "Encoded data should map path variable to correct ID");
                assertTrue(decodedData.getFirst().containsKey(pathVar_id), 
                    "Decoded data should contain mapping for ID");
                assertEquals(decodedData.getFirst().get(pathVar_id), pathVariable, 
                    "Decoded data should map ID back to correct path variable");
            }
        }

        // Now clear the encoding data and test again - IDs should start from beginning
        encodedData.clear();
        decodedData.clear();

        // Test path variables again with cleared data
        for (int i = 0; i < 3; i++) {
            // Get the path variable for this iteration
            String pathVariable = segments[0][0][i]; // level 0, type 0 (path variable), index i
            
            // Make sure the path variable is long enough to be encoded
            if (pathVariable.length() >= minVarLength) {
                // Create URL with domain + path variable
                String url = protocol + "example.com/" + pathVariable;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // After clearing data, IDs should start from 0 again
                String pathVar_id = cs.generateId(i);
                
                // Verify the encoding follows expected pattern: protocol://domainHash/generatedId
                String expectedPattern = protocol + domainHash + "/" + pathVar_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with generated ID for path variable after clearing data");
                
                // Verify the mappings were created correctly
                assertTrue(encodedData.getFirst().containsKey(pathVariable), 
                    "Encoded data should contain the generated ID for path variable");
                assertEquals(encodedData.getFirst().get(pathVariable), pathVar_id, 
                    "Encoded data should map path variable to correct ID");
                assertTrue(decodedData.getFirst().containsKey(pathVar_id), 
                    "Decoded data should contain mapping for ID");
                assertEquals(decodedData.getFirst().get(pathVar_id), pathVariable, 
                    "Decoded data should map ID back to correct path variable");
            }
        }

        // Clear the data again and test level names with query parameters
        encodedData.clear();
        decodedData.clear();

        // Test level names with query parameters
        for (int i = 0; i < 3; i++) {
            // Get segments for this iteration
            String levelName = segments[0][1][i]; // Level name
            String paramName = segments[0][2][i]; // Query parameter name
            String paramValue = segments[0][3][i]; // Query parameter value
            
            // Make sure all segments are long enough to be encoded
            if (levelName.length() >= minParamLength && 
                paramName.length() >= minParamLength && 
                paramValue.length() >= minVarLength) {
                
                // Create URL with domain + level name + query parameter
                String url = protocol + "example.com/" + levelName + "?" + paramName + "=" + paramValue;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // IDs should follow the specified pattern
                String levelName_id = cs.generateId(3 * i);
                String paramName_id = cs.generateId(3 * i + 1);
                String paramValue_id = cs.generateId(3 * i + 2);
                
                // Verify the encoding follows expected pattern
                String expectedPattern = protocol + domainHash + "/" + levelName_id + "?" + paramName_id + "=" + paramValue_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with generated IDs for level name and query params");
                
                // Verify mappings
                assertEquals(levelName_id, encodedData.getFirst().get(levelName), 
                    "Level name should be encoded with ID " + levelName_id);
                assertEquals(paramName_id, encodedData.getFirst().get(paramName), 
                    "Parameter name should be encoded with ID " + paramName_id);
                assertEquals(paramValue_id, encodedData.getFirst().get(paramValue), 
                    "Parameter value should be encoded with ID " + paramValue_id);
            }
        }

        // Now test path variables without clearing the data
        // Path variable IDs should start at 9 (after the 9 existing encodings)
        for (int i = 0; i < 3; i++) {
            String pathVariable = segments[0][0][i]; // Path variable
            
            if (pathVariable.length() >= minVarLength) {
                // Create URL with domain + path variable
                String url = protocol + "example.com/" + pathVariable;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // Path variables should get IDs starting at 9
                String pathVar_id = cs.generateId(9 + i);
                
                // Verify the encoding follows expected pattern
                String expectedPattern = protocol + domainHash + "/" + pathVar_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with generated ID for path variable (after query params)");
                
                // Verify the mappings
                assertEquals(pathVar_id, encodedData.getFirst().get(pathVariable), 
                    "Path variable should be encoded with ID " + pathVar_id);
            }
        }

        // Finally, test URLs with path variables and query parameters
        // Query parameters should reuse existing encodings
        for (int i = 0; i < 3; i++) {
            String pathVariable = segments[0][0][i]; // Path variable
            String paramName = segments[0][2][i];    // Query parameter name
            String paramValue = segments[0][3][i];   // Query parameter value
            
            if (pathVariable.length() >= minVarLength && 
                paramName.length() >= minParamLength && 
                paramValue.length() >= minVarLength) {
                
                // Create URL with domain + path variable + query parameter
                String url = protocol + "example.com/" + pathVariable + "?" + paramName + "=" + paramValue;
                
                // Encode the URL
                String encodedUrl = decoder.encode(url, domainHash, encodedData, decodedData, minVarLength, minParamLength);
                
                // Get the IDs that should be used
                String pathVar_id = cs.generateId(9 + i);           // From the previous loop
                String paramName_id = cs.generateId(3 * i + 1);     // From the first loop in this set
                String paramValue_id = cs.generateId(3 * i + 2);    // From the first loop in this set
                
                // Verify the encoding follows expected pattern
                String expectedPattern = protocol + domainHash + "/" + pathVar_id + "?" + paramName_id + "=" + paramValue_id;
                assertEquals(expectedPattern, encodedUrl, 
                    "Encoded URL should match pattern with correct IDs for path variable and query params");
                
                // Verify the mappings are reused
                assertEquals(pathVar_id, encodedData.getFirst().get(pathVariable), 
                    "Path variable encoding should be reused");
                assertEquals(paramName_id, encodedData.getFirst().get(paramName), 
                    "Parameter name encoding should be reused");
                assertEquals(paramValue_id, encodedData.getFirst().get(paramValue), 
                    "Parameter value encoding should be reused");
            }
        }

        // After all the tests, verify that the maps contain exactly the expected number of elements

        // Verify encoded map size
        assertEquals(12, encodedData.getFirst().size(), 
            "Encoded map should contain exactly 12 elements: 3 level names + 3 path variables + 3 param names + 3 param values");

        // Verify decoded map size
        assertEquals(12, decodedData.getFirst().size(), 
            "Decoded map should contain exactly 12 elements: 3 level names + 3 path variables + 3 param names + 3 param values");

        // Verify each element type is present
        int levelNameCount = 0;
        int pathVarCount = 0;
        int paramNameCount = 0;
        int paramValueCount = 0;

        // Count by checking pattern in keys
        for (String key : encodedData.getFirst().keySet()) {
            if (key.contains("level_name")) {
                levelNameCount++;
            } else if (key.contains("path_variable")) {
                pathVarCount++;
            } else if (key.contains("param_name")) {
                paramNameCount++;
            } else if (key.contains("param_value")) {
                paramValueCount++;
            }
        }

        // Verify counts of each type
        assertEquals(3, levelNameCount, "Should have 3 encoded level names");
        assertEquals(3, pathVarCount, "Should have 3 encoded path variables");
        assertEquals(3, paramNameCount, "Should have 3 encoded parameter names");
        assertEquals(3, paramValueCount, "Should have 3 encoded parameter values");
    }

}
